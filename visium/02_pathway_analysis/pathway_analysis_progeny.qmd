---
title: "20250702_pathway_analysis_progeny"
author: "Tatjana Tomek"
format: html
editor: visual
---

## Pathway analysis on Visium data using PROGENy + decoupleR

investigating biological pathway enrichment in patient Visium datasets

```{r}
# load libraries
library(Seurat)
library(qs)
library(Matrix)
library(hdf5r)
library(decoupleR)
library(tidyverse)
library(patchwork)
library(ggplot2)
library(pheatmap)
library(gridExtra)
library(funkyheatmap)
library(rstatix)
library(ggpubr)
```

## 1. Pathway inference

```{r}
# loading Visium data
visiumlist = qread("/g/saka/Kristy/projects/composite/analysis/rdata/02_13_visium_flt.qs", nthreads = 32)
```

```{r}
# load progeny: pathways, target genes and weights
pr = get_progeny(organism = 'human', top = 10000)

# sum(pr$weight == 0) checking whether beta coefficients of progeny model have been set to 0 for any of the genes (in paper, they only kept coeff of top 100 scoring genes). But is not the case
```

2025-09-09 amendment: instead of importing the PROGENy "pw x gene" matrix of weights using the standard command (importing gene x pw matrix of top 500 genes sorted by p-value): customize PROGENy matrix by\
1. filtering for p-value,\
2. sorting for weight,\
3. extracting top and bottom quartile of genes with the highest weight

```{r}
# looking at progeny weights - check how many genes are significant per pw
pr_sig_split = pr %>%
  filter(p_value < 0.05) %>%
  group_split(source) %>%
  map(~ arrange(.x, weight))

for (i in (pr_sig_split)) {
  print(dim(i))
}
```

Now that pr dfs are filtered by p-value and sorted by weight: take top 25% and bottom 25%

```{r}
top25_split = pr_sig_split %>%
  map(~ bind_rows(
    slice_head(.x, prop = 0.25),
    slice_tail(.x, prop = 0.25)
  ))

pr_custom = bind_rows(top25_split)
```

```{r}
# first, extract sct-transformed count matrices. Maybe run on log norm. count matrices later. Also extract spatial domain annotations
sct_list = map(visiumlist, ~ as.matrix(.x@assays$SCT$data))
#lognorm_list = map(visiumlist, ~ as.matrix(.x@assays$Visium$data))
annot_list = map(visiumlist, ~ as.matrix(.x@meta.data$prelim_growth_2))

```

```{r}
# get patient ids
pat_ids = sub("_.*", "", names(sct_list)) %>% unique()
```

```{r}
# concatenate individual ROI-matrices per patient. 22 count matrices -> 6 count matrices (1 per patient)
pat_masterlist = map(pat_ids, ~ do.call(cbind, sct_list[grep(.x, names(sct_list))])) %>%
  set_names(pat_ids)

# also concatenate spatial domains per patient
master_annot = map(pat_ids, ~ do.call(rbind, annot_list[grep(.x, names(annot_list))])) %>%
  set_names(pat_ids)

# rm visiumlist to not run out of space
rm(visiumlist)
gc()

```

```{r}
# run linear model on all patients - infer pathway activities from gene expression information using pw x gene interaction weights stored in PROGENy
pw_list = lapply(pat_masterlist, function(pat) {
  acts = run_mlm(mat = pat,
                 net = pr_custom,
                 .source = "source",
                 .target = "target",
                 .mor = "weight",
                 minsize = 5)
})
```

## 2. Plotting

### 2.1 ) data wrangling to plot heatmap of pathway activities

```{r}
# make helper funktion
makewidefrompw = function(df, value_col) {
  df %>% pivot_wider(
    id_cols = 'condition',
    names_from = 'source',
    values_from = {{value_col}}
    ) %>% 
    tibble::column_to_rownames(var = 'condition')
}
```

```{r}
# use it to exctract pathway activities and p values from pw_list
act_list = map(pw_list, makewidefrompw, value_col = score)
pval_list = map(pw_list, makewidefrompw, value_col = p_value)
```

```{r}
# add spatial domain identities as column to act_lst, and order rows
act_list = map2(act_list, master_annot, ~ {
  .x$spatial_domain <- .y
  .x[order(.x$spatial_domain), ]
})
```

Save list of pathway activation values and p values

```{r}
qsave(act_list, "/g/saka/Tatjana/data/03_CNVxPW_analysis/01_pw_act_vals_all_roi.qs", 
      nthreads = 32)

qsave(pval_list, "/g/saka/Tatjana/data/03_CNVxPW_analysis/01_pvalues_pw_all_roi.qs", 
      nthreads = 32)
```

```{r}
# also filter act_list based on pval: only keep activity values for each barcode and each pw where the pval < 0.05
act_list_flt = lapply(seq_along(act_list), function(i) {
  df = act_list[[i]]
  pvals = pval_list[[i]]
  
  df[, 1:ncol(pvals)][pvals >= 0.05] <- NA
  df
})
names(act_list_flt) = names(act_list)

qsave(act_list_flt, "/g/saka/Tatjana/data/03_CNVxPW_analysis/01_pw_act_vals_all_roi_flt_pval_smaller_0.05.qs", 
      nthreads = 32)
```

```{r}
# remove certain spatial domains that might not be needed for comparison
spdo_to_remove = c("other")

act_list_flt <- act_list_flt %>%
 map(~ .x %>%
        filter(!spatial_domain %in% spdo_to_remove))
```

```{r}
act_list = act_list %>%
  map(~ .x %>%
        filter(!spatial_domain %in% spdo_to_remove))
```

### 2.2. plot heatmaps

```{r}
# select colors for heatmap plots
# mb ask Kristy for her color scheme, looks very nice

anncolors = list(
  spatial_domain = c(
    diffuse_fdc.hi = "#0072B2",
    diffuse_fdc.lo = "#009E73",
    follicular_fdc.hi = "#CC79A7",
    follicular_fdc.lo = "#F0E442",
    interfollicular_malig.hi = "#D55E00",
    interfollicular_malig.lo = "#E69F00"
    #other = "#A6761D"
  )
)
```

```{r}
# generate all pheatmaps plots into a list
plots = mapply(function(mat, nm) {
  
  ann_row = data.frame(mat$spatial_domain)
  rownames(ann_row) = rownames(mat)
  colnames(ann_row) = "spatial_domain"
  
  # drop annotation colum
  mat_num = as.matrix(mat[ , !(colnames(mat) %in% "spatial_domain")])
  mat

  pheatmap(
    mat_num, 
    show_rownames = FALSE, 
    annotation_row = ann_row,
    annotation_colors = anncolors,
    silent = TRUE,
    cluster_cols = FALSE,
    #cluster_rows = FALSE, # disable when looking at non filtered results
    #na_col = "grey", # disable when looking at non filtered results
    clustering_method = "ward.D2", # disable when cluster_rows = FALSE
    main = nm)
}, act_list, names(act_list), SIMPLIFY = FALSE) # act_list for non-filtered results, #act_list_flt = filtered for p< 0.05


# save all plots
# open png 
png('/g/saka/Tatjana/data/02_pathway_analysis/progeny_decoupler/sct_normalized/pr_custom/pw_acts_pval_unfiltered_custom_pr_FOR_LABMEETING.png', width = 4500, height = 3000, res = 300) 

# to save them together: arrange in grid
grid.arrange(grobs = lapply(plots, function(p) p$gtable), ncol = 3)

dev.off()
```

```{r}
# make helper function for saving pheatmaps 
# from: https://davetang.org/muse/2018/05/15/making-a-heatmap-in-r-with-the-pheatmap-package/
save_pheatmap_png <- function(x, filename, width=1500, height=2000, res=300) {
  png(filename, width=width, height=height, res=res)
  grid::grid.newpage()
  grid::grid.draw(x$gtable)
  dev.off()
}
```

```{r}
for (idx in seq_along(plots)) {
  save_pheatmap_png(plots[[idx]], paste0("/g/saka/Tatjana/data/02_pathway_analysis/progeny_decoupler/sct_normalized/pr_top_500/heatmap_acts_custom_pr_", idx, ".png"))
}

```

```{r}
# now make same plots for pvals:
# generate all pval plots into a list
plots_pv = mapply(function(mat, nm) {
  pheatmap(
    mat, 
    color = c("red", "blue"),
    breaks = c(0, 0.05, 1),
    legend_breaks = c(0, 0.05, 1),
    main = nm,
    show_rownames = FALSE, 
    silent = TRUE,
    cluster_cols = FALSE,
    cluster_rows = FALSE)
}, pval_list, names(pval_list), SIMPLIFY = FALSE)

# open png 
png("/g/saka/Tatjana/data/02_pathway_analysis/progeny_decoupler/sct_normalized/pr_custom/progeny_pvals_custom_FOR_LABMEETING.png", width = 4500, height = 3000, res = 300) 

# to save them together: arrange in grid
grid.arrange(grobs = lapply(plots_pv, function(p) p$gtable), ncol = 3)
dev.off()

```

### Make violin plots for all samples

```{r}
## amendment 2025-10-25: we did not end up focusing on pathway differences between spatial domains, but rather pathway differences between Visium spots containing certain CNVs vs. not containing CNVs - below code is not being used.
act_list_flt_long = act_list_flt %>%
  map(~ .x %>%
        mutate(spatial_domain = as.factor(spatial_domain)) %>%
        rownames_to_column("barcode") %>%
        pivot_longer(
          cols = -c("spatial_domain", "barcode"),
          names_to = "pathway",
          values_to = "activity"
        )
  )
```

```{r}
# use kruskal wallis test to calc whether there is a sign. difference between pathway activation values actoss spatial domains. Omnibus test, maybe delete since we have dunns test
stats = act_list_flt_long %>%
  map(~ .x %>%
        group_by(pathway) %>%
        kruskal_test(activity ~ spatial_domain)
      )
```

```{r}
# do posthoc test (dunn) to identify which domains are sign. different in their pathway activation value
posthoc = act_list_flt_long %>% 
  map(~ .x %>%
        group_by(pathway) %>%
        dunn_test(activity ~ spatial_domain, p.adjust.method = "BH") %>%
        add_xy_position(x = "spatial_domain")
      )

```

```{r}
# count non-na values for all patients
nonnacount = act_list_flt_long %>%
  map(~ .x %>% 
        group_by(pathway, spatial_domain) %>%
        summarize(non_na = sum(!is.na(activity)), .groups = "drop")
      ) 
```

```{r}
# make violin plots for all patient samples 
plots = map2(
  act_list_flt_long,
  nonnacount,
  ~ ggplot(.x, aes(x = spatial_domain, y = activity)) +
    geom_violin(trim = FALSE) +
    geom_boxplot(width = 0.1, outlier.shape = NA, alpha = 0.3) +
    geom_text(data = .y, 
              aes(x = spatial_domain, 
                  y = min(.x$activity, na.rm = TRUE) - 0.5, 
                  label = non_na),
              inherit.aes = FALSE, size = 3) +
    facet_wrap(~ pathway, scales = "free_y", ncol = 4) +
    theme_bw() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1),
          strip.text = element_text(face = "bold"))
)

plots_with_stats = map2(
  plots,
  posthoc,
  ~ .x + stat_pvalue_manual(
    data = .y,
    label = "p.adj.signif", 
    xmin = "xmin",
    xmax = "xmax",
    tip.length = 0.01,
    hide.ns = TRUE
  )
)


```

```{r}
for (idx in seq_along(plots_with_stats)) {
  ggsave(paste0("/g/saka/Tatjana/data/02_pathway_analysis/progeny_decoupler/sct_normalized/pr_custom/violinplot_cust_4cols_FORLABMEETING", idx, "_FOR_LABMEETING2.png"), plots_with_stats[[idx]], width = 20, height = 15, dpi = 300)
}
```
