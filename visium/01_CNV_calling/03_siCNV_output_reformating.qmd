---
title: "20250430_siCNV_outputs"
author: "Tatjana"
format: html
editor: visual
---

## siCNV outputs reformating

script for reformating the outputs of inferCNV to obtain following info for each CNV:\
1.) which barcodes was it detected\
2.) what is probability of cnv being there\
3.) cnv state (amp or del; nr in range of 1-6)

```{r}
# loading libraries
library(Seurat)
library(SeuratObject)
library(tidyverse)
library(magrittr)
library(qs)
library(infercnv)
```

```{r}
# loading output of "spot-based" infercnv run, singular ROI: LN0040HD_12BV2R_R1
# raw results (post MCMC)
cnv_regs_spots_r = read.table("/scratch/tomek/01_siCNV/RESULTS_spotbased_infercnv_per_roi/jobarray_all_pat_roi_per_spot_BayesMaxPNormal_0.3/LN0040HD_12BV2R_R1/17_HMM_predHMMi6.hmm_mode-cells.pred_cnv_regions.dat", sep = "\t", header = TRUE)

# read in whole Visium spot-based mcmc infercnv object
mcmc_spots = readRDS("/scratch/tomek/01_siCNV/RESULTS_spotbased_infercnv_per_roi/jobarray_all_pat_roi_per_spot_BayesMaxPNormal_0.3/LN0040HD_12BV2R_R1/BayesNetOutput.HMMi6.hmm_mode-cells/MCMC_inferCNV_obj.rds")
```

```{r}
# start of data reformating: "cell_probabilities" slot in mcmc object.
cellprobs = mcmc_spots@cell_probabilities
# get their names from cnv_regions slot
names(cellprobs) = as.character(mcmc_spots@cnv_regions)

# cellprobs not state the barcode where each cnv appears - get bc information from count.data, and match it to cnvs in second step using the integer barcode indices in "cell_gene" slot of mcmc object
bc = colnames(mcmc_spots@count.data)
```

```{r}
# obtain barcode names by matching bc indices to bc names
cellprobs = map2(
  cellprobs,
  mcmc_spots@cell_gene,
  ~ {
    # integer barcode indices from cell_gene, look for bc names in "bc"
    barcode_idx = as.integer(.y$Cells)
    colnames(.x) - bc[barcode_idx]
    .x
  }
)
```

```{r}
# use "cellprobs" list to make df of cnvs - to later match match with raw output file "cnv_regs_spots_r" to get remaining cols that are necessary for downstream analysis (chr, start & stop genomic coords)
cnvs_raw = data.frame(
  cnv_name = names(cellprobs),
  bc_name = sapply(cellprobs, function(x) colnames(x)),
  p = sapply(cellprobs, function(x) max(x[, 1])),
  state_mcmc = sapply(cellprobs, function(x) rownames(x)[which.max(x[, 1])]),
  stringsAsFactors = FALSE
)

```

```{r}
# prototype of final res: extracted info from mcmc object (= post mcmc, post bayes net -> only keep most probable cnvs) & merged with most important cols of raw "cnv_regs_spots_r" output file
cnvs_proto = cnvs_raw %>%
  left_join(
    cnv_regs_spots_r %>%
      select(cnv_name, cell_group_name, state, chr, start, end),
    by = c("cnv_name" = "cnv_name", "bc_name" = "cell_group_name")
  )
```

```{r}
# last steps: apply qc filtering thresholds to cnvs called: remove all cnvs with reported state "3" in col "state_mcmc" (="normal", no amp/del), remove all cnvs with probability (col: "p") < 0.7, to keep only high confidence cnvs
cnvs_fin = cnvs_proto[cnvs_proto$state_mcmc != 3 &
                      cnvs_proto$p > 0.7, ]
```

```{r}
# save final result
write.table(cnvs_fin, "/g/saka/Tatjana/data/data_for_testing_stuff/prelim_cnv_analysis_spotbased/pat40HD_R1_cnvs_extracted_from_mcmc_infcnvobj.cnv",
            row.names = FALSE,
            col.names = TRUE,
            sep = "\t")

```
