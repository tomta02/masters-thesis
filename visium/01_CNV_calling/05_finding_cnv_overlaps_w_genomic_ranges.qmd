---
title: "20250426_genomic_ranges"
author: "Tatjana Tomek"
format: html
editor: visual
---

## Computing CNV overlaps with GenomicRanges

Aiming to calculate CNV overlaps for inferCNV output data that was calculated on a "per visium spot-basis" rather than "per spatial domain-basis" (as was done previously).

```{r}
# load libraries
library(tidyverse)
library(magrittr)
library(qs)
library(GenomicRanges)
library(Gviz)
library(rtracklayer)
```

```{r}
# load in trial dataset of "per visium spot cnv calls"
test = read.table("/scratch/tomek/01_siCNV/RESULTS_spotbased_infercnv_per_roi/LN0040HD/LN0040HD_12BV2R_R1/HMM_CNV_predictions.HMMi6.hmm_mode-cells.Pnorm_0.5.pred_cnv_regions.dat", header = TRUE)
```

all the reference cells are also in the infercnv output data. Separate them from the actual patient barcodes and analyze individually

```{r}
# filter out the rows in "roi_data_concat" that contain our sample name 
test_subset_to_keep = grep(paste0("^", "LN0040HD", "_"), test$cell_group_name)
test_flt = test[test_subset_to_keep, , drop=FALSE]
test_flt_lst = split(test_flt, test_flt$chr)
```

Construct GRanges object

```{r}
gr_list = lapply(test_flt_lst, function(bc) {
  GRanges(
    seqnames = bc$chr,
    ranges = IRanges(
      start = bc$start,
      end = bc$end, 
      names = bc$cnv_name),
    barcode = bc$cell_group_name,
    state = bc$state,
    cnv_name = bc$cnv_name
    )
  })
```

```{r}
# instead of list of genomic ranges objects, actually try following operations on singular genomics ranges object
gr = GRanges(seqnames = test_flt$chr,
             ranges = IRanges(
               start = test_flt$start,
               end = test_flt$end,
               names = test_flt$cnv_name),
              barcode = test_flt$cell_group_name,
              state = test_flt$state,
              cnv_name = test_flt$cnv_name
             )
```

Now, reduce genomic ranges object to focus on CNVs that were found in all cells (but keep track of metadata (bc name))

```{r}
#grr = reduce(gr, with.revmap = TRUE)

#mcols(grr) = do.call(rbind,
                      #lapply(mcols(grr)$revmap, function(i) {
                        #data.frame(
                          #bc = paste(mcols(gr)$bc[ i ], collapse = ","),
                          #state = paste(mcols(gr)$state[ i ], collapse = ","),
                          #cnv_name = paste(mcols(gr)$cnv_name[ i ], collapse = ","))
                        #}))
```

```{r}
# testing to see how often each state appears.
# starting with "reduced cnv: 1
# Example input
#test_cnv = grr[9]$state

#numbers = as.integer(strsplit(test_cnv, ",")[[1]])

#count_table = table(factor(numbers, levels = 1:6))

#for (i in 1:6) {
  #cat(i, ":", count_table[i], "\n")
#}

```

Note: did not proceed with "reduced" cnvs, as data is quite sparse -\> reducing our cnvs across spots leads to the artificial creation of very few unusually large cnvs, as barely overlapping cnvs are joined when applying "reduce"

## CNV analysis

Crude analysis:

1.) find overlaps between CNVs

2.) define function to only count CNVs as "matching" when they overlap at least 70%

3.) reduce these CNVs that were identified in step 2.)

```{r}
#cnv_overlaps = findOverlaps(gr, gr)
#cnv_overlaps_flt = cnv_overlaps[queryHits(cnv_overlaps) < subjectHits(cnv_overlaps)]
```

```{r}
#hits_70pct = cnv_overlaps_flt[sapply(seq_along(cnv_overlaps_flt), function(i) {
  
  #hit1 = gr[queryHits(cnv_overlaps_flt)[i]]
  #hit2 = gr[subjectHits(cnv_overlaps_flt)[i]]
  
  #print(hit1)
  #print(hit2)
  #intrsct = pintersect(hit1, hit2)
  #intrsct_width = width(intrsct)
  
  #min(width(hit1), width(hit2)) > 0 &&
    #intrsct_width / width(hit1) >= 0.7 &&
    #intrsct_width / width(hit2) >= 0.7
#})]
```

### not fast enough - use binned genome approach

```{r}
genome = GRangesForBSGenome('hg38') 
binnedgenome = tileGenome(seqlengths = seqinfo(genome), tilewidth=10000) # returns a list for each bin
binnedgenome = unlist(binnedgenome) #%>% dropSeqlevels(binnedgenome, c('chrM','chrY'), pruning.mode = 'coarse')
```

after talking to Kristy: trying opposite approach - use binned genome as query and cnvs as subject

```{r}
hits = lapply(gr_list, function(bc_gr) {
  findOverlaps(binnedgenome, bc_gr)
})
```

test function with one element

```{r}
hitstest = hits[[1]]
grtest = gr_list[[1]]
```

```{r}
# reformating the genomic bins into genomic coordinates (start/stop)
# this was too computationally heavy for RStudio - connected to cluster via srun and did it interactively, saved resulting list and will load below
#gr_list = mapply(function(bc_gr, bc_hits) {
  #bc_gr$bin_start = queryHits(bc_hits[1])
  #bc_gr$bin_stop = queryHits(bc_hits[length(bc_hits)])
  #bc_gr
#}, gr_list, hits, SIMPLIFY = FALSE)
```

```{r}
# load gr_list
gr_list2 = readRDS("/g/saka/Tatjana/data/data_for_testing_stuff/LN0040HD_12BV2R_R1_spotbased_cnv_results_matched_to_binned_genome.RData")
```

```{r}
# make func for adding bin start & stop vals
add_bin_startstop + function(gr) {
  
  # initialize values
  n = length(gr)
  bin_start = rep(NA_integer_, n)
  bin_stop = rep(NA_integer_, n)
  
  for (i in seq_len(n)) {
    bins = gr$bin_ids[[i]]
    
    # are bins not emoty and numeric? if so, add start & stop vals
    if (!is.null(bins) && length(bins) > 0 && is.numeric(bins)) {
      bin_start[i] = min(bins)
      bin_stop[i] = max(bins)
    }
  }
  gr$bin_start = bin_start
  gr$bin_stop = bin_stop
  
  gr
}

```

```{r}
gr_list_w_start_stop = lapply(gr_list2, add_bin_start_stop)
gr_list_w_start_stop = GRangesList(gr_list_w_start_stop)
```

NOW: unlist, , pattern matching

```{r}
gr_w_start_stop = unlist(gr_list_w_start_stop, use.names = FALSE)
```

```{r}
# converting to df, as calculating overlaps will prob be faster
trial = as.data.frame(gr_w_start_stop)
trial$seqnames = as.character(test2$seqnames)
```

```{r}
# order 
trial = test2[order(test2$seqnames, test2$bin_start), ]
```

Ditch binned genome approach and compare CNVs to one another

```{r}
hits = findOverlaps(gr, gr)
hits_df = as.data.frame(hits)

# GET RID OFself-comparisons and duplicates (otherwise we get stuff like., A vs B and B vs A), no need

hits_df = hits_df %>% filter(queryHits < subjectHits)

# add data from genomic ranges object as metadata to hits_df
hits_df = hits_df %>%
  mutate(
    state_q = mcols(gr)$state[queryHits],
    state_s = mcols(gr)$state[subjectHits],
    start_q = start(gr)[queryHits],
    end_q = end(gr)[queryHits],
    start_s = start(gr)[subjectHits],
    end_s = end(gr)[subjectHits]
)
```

```{r}
hits_df = hits_df %>% filter(
    state_q == state_s & 
    as.character(seqnames(gr)[queryHits]) == as.character(seqnames(gr)[subjectHits])
)
```

```{r}
# get final overlaps
hits_df = hits_df %>%
  mutate(
    overlap_start = pmax(start_q, start_s),
    overlap_end = pmin(end_q, end_s),
    overlap_width = pmax(0, overlap_end - overlap_start + 1),
    width_q = end_q - start_q + 1,
    width_s = end_s - start_s + 1,
    prop_q = overlap_width/width_q,
    prop_s = overlap_width/width_s
  ) %>%
  filter(prop_q > 0.7 & prop_s > 0.7)

```
