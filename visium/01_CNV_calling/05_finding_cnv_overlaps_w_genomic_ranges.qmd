---
title: "20250426_genomic_ranges"
author: "Tatjana Tomek"
format: html
editor: visual
---

## Computing CNV overlaps with GenomicRanges

Aiming to calculate CNV overlaps for inferCNV output data that was calculated on a "per visium spot-basis" rather than "per spatial domain-basis" (as was done previously).

```{r}
# load libraries
library(tidyverse)
library(magrittr)
library(qs)
library(GenomicRanges)
library(Gviz)
library(rtracklayer)
```

```{r}
# load in trial dataset of "per visium spot cnv calls"
test = read.table("/scratch/tomek/01_siCNV/RESULTS_spotbased_infercnv_per_roi/LN0040HD/LN0040HD_12BV2R_R1/HMM_CNV_predictions.HMMi6.hmm_mode-cells.Pnorm_0.5.pred_cnv_regions.dat", header = TRUE)
```

Interesting: all the reference cells are also in the infercnv output data. Separate them from the actual patient barcodes and analyze individually

```{r}
# filter out the rows in "roi_data_concat" that contain our sample name 
test_subset_to_keep = grep(paste0("^", "LN0040HD", "_"), test$cell_group_name)
test_filtered = test[test_subset_to_keep, , drop=FALSE]
```

1st step: use IRanges constructor to construct IRanges object with start/stop values for our CNVs

```{r}
cnvranges = IRanges(
  start = test_filtered$start, 
  end = test_filtered$end, 
  names = test_filtered$cnv_name
  )
```

Next, construct GRanges object

```{r}
gr = GRanges(
  seqnames = test_filtered$chr,
  ranges = cnvranges,
  bc = test_filtered$cell_group_name,
  state = test_filtered$state,
  cnv_name = test_filtered$cnv_name
  )
```

Now, reduce genomic ranges object to focus on CNVs that were found in all cells (but keep track of metadata (bc name))

```{r}
grr = reduce(gr, with.revmap = TRUE)

mcols(grr) = do.call(rbind,
                      lapply(mcols(grr)$revmap, function(i) {
                        data.frame(
                          bc = paste(mcols(gr)$bc[ i ], collapse = ","),
                          state = paste(mcols(gr)$state[ i ], collapse = ","),
                          cnv_name = paste(mcols(gr)$cnv_name[ i ], collapse = ","))
                        }))
```

```{r}
# testing to see how often each state appears.
# starting with "reduced cnv: 1
# Example input
test_cnv = grr[9]$state

numbers = as.integer(strsplit(test_cnv, ",")[[1]])

count_table = table(factor(numbers, levels = 1:6))

for (i in 1:6) {
  cat(i, ":", count_table[i], "\n")
}

```

## CNV analysis

As seen from the plot, the CNVs still encompass the whole chromosome when we apply GenomicRanges::reduce, so we need to find another way.

Crude analysis:

1.) find overlaps between CNVs

2.) define function to only count CNVs as "matching" when they overlap at least 70%

3.) reduce these CNVs that were identified in step 2.)

```{r}
#cnv_overlaps = findOverlaps(gr, gr)
#cnv_overlaps_flt = cnv_overlaps[queryHits(cnv_overlaps) < subjectHits(cnv_overlaps)]
```

```{r}
#hits_70pct = cnv_overlaps_flt[sapply(seq_along(cnv_overlaps_flt), function(i) {
  
  #hit1 = gr[queryHits(cnv_overlaps_flt)[i]]
  #hit2 = gr[subjectHits(cnv_overlaps_flt)[i]]
  
  #print(hit1)
  #print(hit2)
  #intrsct = pintersect(hit1, hit2)
  #intrsct_width = width(intrsct)
  
  #min(width(hit1), width(hit2)) > 0 &&
    #intrsct_width / width(hit1) >= 0.7 &&
    #intrsct_width / width(hit2) >= 0.7
#})]
```

### None of the above is fast enough - use binned genome approach

```{r}
genome = GRangesForBSGenome('hg38') 
binnedgenome = tileGenome(seqlengths = seqinfo(genome), tilewidth=10000) # returns a list for each bin
binnedgenome = unlist(binnedgenome) #%>% dropSeqlevels(binnedgenome, c('chrM','chrY'), pruning.mode = 'coarse')
```

```{r}
hits = findOverlaps(gr, binnedgenome)
```

```{r}
gr$bin_ids = split(subjectHits(hits), queryHits(hits))
```

```{r}
# Turn bin indices into strings for grouping
gr$bin_signature = sapply(gr$bin_ids, function(b) paste(sort(b), collapse = "-"))
```

```{r}
# Group by shared signature
gr_collapsed = split(gr, gr$bin_signature)
```
