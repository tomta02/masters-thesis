---
title: "20250426_genomic_ranges"
author: "Tatjana Tomek"
format: html
editor: visual
---

## Computing CNV overlaps with GenomicRanges

Aiming to calculate CNV overlaps for inferCNV output data that was calculated on a "per visium spot-basis" rather than "per spatial domain-basis" (as was done previously).

```{r}
# load libraries
library(tidyverse)
library(magrittr)
library(qs)
library(GenomicRanges)
library(Gviz)
library(rtracklayer)
library(igraph)
```

```{r}
# load in trial dataset of "per visium spot cnv calls"
test = read.table("/scratch/tomek/01_siCNV/RESULTS_spotbased_infercnv_per_roi/LN0040HD/LN0040HD_12BV2R_R1/HMM_CNV_predictions.HMMi6.hmm_mode-cells.Pnorm_0.5.pred_cnv_regions.dat", header = TRUE)
```

all the reference cells are also in the infercnv output data. Separate them from the actual patient barcodes and analyze individually

```{r}
# filter out the rows in "roi_data_concat" that contain our sample name 
test_subset_to_keep = grep(paste0("^", "LN0040HD", "_"), test$cell_group_name)
test_flt = test[test_subset_to_keep, , drop=FALSE]
test_flt_lst = split(test_flt, test_flt$chr)
```

Construct GRanges object

```{r}
gr_list = lapply(test_flt_lst, function(bc) {
  GRanges(
    seqnames = bc$chr,
    ranges = IRanges(
      start = bc$start,
      end = bc$end, 
      names = bc$cnv_name),
    barcode = bc$cell_group_name,
    state = bc$state,
    cnv_name = bc$cnv_name
    )
  })
```

```{r}
# instead of list of genomic ranges objects, actually try following operations on singular genomics ranges object
gr = GRanges(seqnames = test_flt$chr,
             ranges = IRanges(
               start = test_flt$start,
               end = test_flt$end,
               names = test_flt$cnv_name),
              barcode = test_flt$cell_group_name,
              state = test_flt$state,
              cnv_name = test_flt$cnv_name
             )
```

Now, reduce genomic ranges object to focus on CNVs that were found in all cells (but keep track of metadata (bc name))

```{r}
#grr = reduce(gr, with.revmap = TRUE)

#mcols(grr) = do.call(rbind,
                      #lapply(mcols(grr)$revmap, function(i) {
                        #data.frame(
                          #bc = paste(mcols(gr)$bc[ i ], collapse = ","),
                          #state = paste(mcols(gr)$state[ i ], collapse = ","),
                          #cnv_name = paste(mcols(gr)$cnv_name[ i ], collapse = ","))
                        #}))
```

```{r}
# testing to see how often each state appears.
# starting with "reduced cnv: 1
# Example input
#test_cnv = grr[9]$state

#numbers = as.integer(strsplit(test_cnv, ",")[[1]])

#count_table = table(factor(numbers, levels = 1:6))

#for (i in 1:6) {
  #cat(i, ":", count_table[i], "\n")
#}

```

Note: did not proceed with "reduced" cnvs, as data is quite sparse -\> reducing our cnvs across spots leads to the artificial creation of very few unusually large cnvs, as barely overlapping cnvs are joined when applying "reduce"

# CNV analysis

Crude analysis:

1.) find overlaps between CNVs

2.) define function to only count CNVs as "matching" when they overlap at least 70%

(3.) reduce these CNVs that were identified in step 2.))

### Use binned genome approach

```{r}
genome = GRangesForBSGenome('hg38') 
binnedgenome = tileGenome(seqlengths = seqinfo(genome), tilewidth=10000) # returns a list for each bin
binnedgenome = unlist(binnedgenome) #%>% dropSeqlevels(binnedgenome, c('chrM','chrY'), pruning.mode = 'coarse')
```

after talking to Kristy: trying opposite approach - use binned genome as query and cnvs as subject

```{r}
hits = lapply(gr_list, function(bc_gr) {
  findOverlaps(binnedgenome, bc_gr)
})
```

```{r}
# test function with one element
#hitstest = hits[[1]]
#grtest = gr_list[[1]]
```

```{r}
# reformating the genomic bins into genomic coordinates (start/stop)
# this was too computationally heavy for RStudio - connected to cluster via srun and did it interactively, saved resulting list and will load below
#gr_list = mapply(function(bc_gr, bc_hits) {
  #bc_gr$bin_start = queryHits(bc_hits[1])
  #bc_gr$bin_stop = queryHits(bc_hits[length(bc_hits)])
  #bc_gr
#}, gr_list, hits, SIMPLIFY = FALSE)
```

```{r}
# load gr_list
gr_list2 = readRDS("/g/saka/Tatjana/data/data_for_testing_stuff/LN0040HD_12BV2R_R1_spotbased_cnv_results_matched_to_binned_genome.RData")
```

```{r}
# make func for adding bin start & stop vals
add_bin_startstop = function(gr) {
  
  # initialize values
  n = length(gr)
  bin_start = rep(NA_integer_, n)
  bin_stop = rep(NA_integer_, n)
  
  for (i in seq_len(n)) {
    bins = gr$bin_ids[[i]]
    
    # are bins not emoty and numeric? if so, add start & stop vals
    if (!is.null(bins) && length(bins) > 0 && is.numeric(bins)) {
      bin_start[i] = min(bins)
      bin_stop[i] = max(bins)
    }
  }
  gr$bin_start = bin_start
  gr$bin_stop = bin_stop
  
  gr
}

```

```{r}
gr_lst_start_stop = lapply(gr_list2, add_bin_startstop)
gr_lst_start_stop = GRangesList(gr_lst_start_stop)
gr_start_stop = unlist(gr_lst_start_stop, use.names=FALSE)
gr_lst_start_stop = split(gr_start_stop, gr_start_stop@seqnames)
```

### Continuing analysis based on converstation w. Kristy

-   convert GRanges objects to df, drop the cols that are not needed

-   group by bin_id and cnv state, then run summary statistics

```{r}
gr_lst_start_stop_dfs = lapply(gr_lst_start_stop, as.data.frame)
```

```{r}
# keep only the cols of interest
gr_lst_start_stop_dfs = lapply(gr_lst_start_stop_dfs, function(df) {
  df %>% select(seqnames, barcode, state, bin_start, bin_stop)
})

# also, make new rownames based on chromosome, bin_start and bin_stop
gr_lst_start_stop_dfs = lapply(gr_lst_start_stop_dfs, function(df) {
  # Create new rownames
  newnames = paste0(df$seqnames, "_", df$bin_start, "_", df$bin_stop)
  rownames(df) = make.unique(newnames)
  return(df)
})
```

```{r}
gr_lst_start_stop_dfs = lapply(gr_lst_start_stop_dfs, function(df) {
  df = rownames_to_column(df, "bin_ID")
  return(df)
})
```

```{r}
gr_lst_start_stop_dfs = lapply(gr_lst_start_stop_dfs, function(df) {
  df = df %>% group_by(bin_ID) #, state)
  return(df)
})
```

### overlapped cnvs to genome, but still want to find cnvs with x % overlap to others... need to findOverlaps with self instead?

```{r}
#getoverlappingranges = function(gr) {
  hitsgr = findOverlaps(gr, gr)
  hitsgr_df = as.data.frame(hitsgr) 
  
  hitsgr_df = hitsgr_df %>% filter(queryHits < subjectHits) 
  
  
  # to do filtering on X % overlap of query and subject ranges, 
  # add metadata from genomicranges object
  hitsgr_df = hitsgr_df %>% 
    mutate(
      state_q = mcols(gr)$state[queryHits],
      state_s = mcols(gr)$state[subjectHits],
      start_q = start(gr)[queryHits],
      end_q = end(gr)[queryHits],
      start_s = start(gr)[subjectHits],
      end_s = end(gr)[subjectHits]
      ) 
  # now, keep only hits where the state was the same
 hitsgr_df = hitsgr_df %>% filter(state_q == state_s) # uncomment this and try again - compare
  
  # now, calculate overlaps of cnvs with one another
  hitsgr_df = hitsgr_df %>% 
    mutate(
      overlap_start = pmax(start_q, start_s),
      overlap_end = pmin(end_q, end_s),
      overlap_width = pmax(0, overlap_end - overlap_start + 1),
      width_q = end_q - start_q + 1,
      width_s = end_s - start_s + 1,
      prop_q = overlap_width / width_q,
      prop_s = overlap_width / width_s
    )
  
  # now, only keep the cnvs that have a X % overlap with some other CNV - chose 70% for now
  hitsgr_df = hitsgr_df %>% filter(prop_q > 0.7 & prop_s > 0.7)
  
  # last: get indices of overlapping cnvs, to filter the original GRanges object
  # and return filtered GRanges object
  overlapids = unique(c(hitsgr_df$queryHits, hitsgr_df$subjectHits))
  
 # return(gr[overlapids])
#}

```

```{r}
#overlapping_cnvs = lapply(gr_lst_start_stop, getoverlappingranges)
```

```{r}
overlapping_cnvs = gr[overlapids]
```

```{r}
reduce_cnvs = reduce(overlapping_cnvs)
```

## Graph-based approach?

```{r}
# here: continue from filtered "hitsgr_df" from above
# Build graph from edges
g = graph_from_data_frame(d = hits_df[, c("queryHits", "subjectHits")], directed = FALSE, vertices = seq_along(gr))

# Step 5: Find maximal cliques of size >= 2
cliques = max.cliques(g, min = 2)

# Optional: Filter cliques by size or other criteria
# For example, only keep cliques with all nodes overlapping pairwise >70%
# (maximal.cliques guarantees that all nodes in clique are connected)

# Step 6: Get the sequences involved in any clique
clique_indices = unique(unlist(cliques))

# Subset gr to only sequences involved in at least one clique
overlapping_sequences = gr[clique_indices]


```

```{r}
# try reducing overlapping sequences
red_overlapping_seqs = reduce(overlapping_sequences)
```

```{r}
clique_gr_list = lapply(cliques, function(clique_vertices) {
  gr[clique_vertices]
})

# Now you have a list of GRanges, each corresponding to one clique

# Apply reduce() per clique to merge overlapping ranges within each clique
reduced_cliques = lapply(clique_gr_list, reduce)

# Optional: remove empty cliques or filter by size
#reduced_cliques <- Filter(length, reduced_cliques)
```

```{r}
clique_gr_list = lapply(cliques, function(clique_vertices) {
  gr[as.integer(clique_vertices)]  # convert igraph.vs to integer indices
})

# Then apply reduce as before
reduced_cliques = lapply(clique_gr_list, reduce)

```
